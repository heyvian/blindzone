<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>The Blind Zone</title>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;800;900&display=swap" rel="stylesheet">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.6.0/p5.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
  <style>
    /* --- RESET & BASE --- */
    body { 
      margin: 0; padding: 0; background: #f4f4f9; 
      font-family: 'Inter', sans-serif; 
      overflow: hidden; user-select: none; 
      touch-action: none; -webkit-touch-callout: none;
    }
    
    /* --- HUD (Top Bar) --- */
    #hud-top {
      position: absolute; top: 0; left: 0; width: 100%; height: 80px;
      background: rgba(255, 255, 255, 0.98); 
      border-bottom: 1px solid #e0e0e0;
      display: flex; align-items: center; justify-content: space-between;
      padding: 0 20px; box-sizing: border-box; 
      z-index: 100; box-shadow: 0 4px 12px rgba(0,0,0,0.03);
    }

    .brand { display: flex; flex-direction: column; min-width: 220px; }
    .brand h1 { margin: 0; font-size: 20px; font-weight: 900; color: #111; letter-spacing: -1px; line-height: 1; font-style: italic; }
    .brand span { font-size: 10px; color: #d32f2f; font-weight: 700; text-transform: uppercase; letter-spacing: 0.5px; margin-top: 4px; }

    .score-container { text-align: center; position: absolute; left: 50%; transform: translateX(-50%); }
    .score-val { font-size: 32px; font-weight: 900; color: #111; line-height: 1; }
    .score-label { font-size: 10px; text-transform: uppercase; letter-spacing: 1.5px; color: #888; font-weight: 700; margin-top: 4px; }

    .right-controls { display: flex; gap: 8px; align-items: center; }
    
    .vehicle-selector {
      padding: 0 12px; font-size: 14px; border-radius: 6px; border: 1px solid #ccc;
      background: #fff; cursor: pointer; font-family: 'Inter', sans-serif; font-weight: 600; color: #333;
      outline: none; transition: all 0.2s; height: 36px;
    }

    .btn-hud {
      padding: 0 12px; height: 36px; font-size: 13px; font-weight: 700; border-radius: 6px; 
      border: 1px solid #ddd; background: #fff; cursor: pointer; color: #555;
      transition: all 0.2s; display: flex; align-items: center; gap: 6px; white-space: nowrap;
    }
    .btn-hud:hover { background: #f0f0f0; color: #111; border-color: #999; }
    .icon { font-size: 16px; font-weight: bold; color: #d32f2f; }
    .fs-icon { font-size: 18px; line-height: 1; color: #555; }

    /* --- SIDEBAR --- */
    #sidebar-right {
      position: absolute; top: 90px; right: 20px;
      background: white; padding: 15px; border-radius: 12px;
      box-shadow: 0 4px 20px rgba(0,0,0,0.08); width: 120px;
      text-align: center; z-index: 50; border: 1px solid #eee;
      cursor: pointer; transition: transform 0.1s;
    }
    #sidebar-right:active { transform: scale(0.98); background: #fafafa; }
    
    .panel-title { font-size: 10px; font-weight: 800; color: #aaa; text-transform: uppercase; letter-spacing: 1px; margin-bottom: 12px; }
    #queue-visuals { display: flex; flex-direction: column; align-items: center; gap: 10px; margin-bottom: 15px; pointer-events: none; }
    
    .key-hint { font-size: 11px; color: #666; background: #f0f0f0; padding: 8px; border-radius: 8px; font-weight: 600; line-height: 1.4; pointer-events: none; }
    .key { background: #fff; border: 1px solid #ccc; padding: 2px 6px; border-radius: 4px; box-shadow: 0 2px 0 #ddd; color: #111; }
    
    .btn-toggle-stance {
      margin-top: 10px; width: 100%; padding: 8px; 
      background: #333; color: white; border: none; 
      border-radius: 6px; font-weight: 700; font-size: 10px;
      text-transform: uppercase; letter-spacing: 0.5px;
      pointer-events: none; /* Let the parent div handle the click */
    }

    /* --- PERMANENT INSTRUCTIONS --- */
    #sky-text {
      position: absolute; top: 100px; width: 100%;
      text-align: center; pointer-events: none; z-index: 10;
      display: flex; flex-direction: column; align-items: center; justify-content: center;
    }
    #sky-text h3 { margin: 0 0 6px 0; font-size: 16px; font-weight: 800; color: #888; width: 60%; line-height: 1.3; }
    #sky-text p { margin: 0; font-size: 13px; font-weight: 500; color: #aaa; width: 60%; line-height: 1.4; }

    /* --- OVERLAYS --- */
    #overlay-container {
      position: absolute; top: 0; left: 0; width: 100%; height: 100%;
      pointer-events: none; z-index: 200; 
      display: flex; align-items: center; justify-content: center;
    }
    
    #rotate-device {
      position: fixed; top: 0; left: 0; width: 100%; height: 100%;
      background: #111; color: white; z-index: 9999;
      display: none; align-items: center; justify-content: center; flex-direction: column;
      text-align: center; padding: 40px; box-sizing: border-box;
    }
    .rotate-icon { font-size: 40px; margin-bottom: 20px; }
    
    @media (orientation: portrait) and (max-width: 1024px) {
      #rotate-device { display: flex; }
      #hud-top, #sidebar-right { display: none; }
    }

    .modal-card {
      background: rgba(255, 255, 255, 0.99); 
      padding: 30px; border-radius: 20px; text-align: center;
      box-shadow: 0 25px 60px -10px rgba(0, 0, 0, 0.3);
      pointer-events: auto; max-width: 500px; width: 85%;
      display: none; backdrop-filter: blur(10px);
      border: 1px solid rgba(0,0,0,0.1); position: relative;
    }
    
    #warning-card { border: 4px solid #d32f2f; }
    .warning-text { font-size: 18px; font-weight: 800; color: #d32f2f; margin-bottom: 20px; line-height: 1.4; }
    
    #gameover-card { background: rgba(15, 15, 15, 0.96); color: white; border: 1px solid #333; }
    #gameover-card h2 { margin: 0 0 10px 0; font-size: 24px; color: #ff5252; font-weight: 900; letter-spacing: -0.5px; text-transform: uppercase; }
    #gameover-subtitle { font-size: 14px; color: #aaa; margin-bottom: 20px; line-height: 1.5; font-style: italic; }
    
    #receipt-list { 
      text-align: left; margin: 0 auto 20px auto; width: 100%; 
      border-top: 1px dashed #444; border-bottom: 1px dashed #444; padding: 10px 0;
    }
    .list-row { display: flex; justify-content: space-between; align-items: baseline; margin-bottom: 6px; font-size: 15px; color: #eee; font-weight: 500; }
    .list-label { flex-grow: 1; overflow: hidden; white-space: nowrap; position: relative; }
    .list-label::after { content: " ........................................................................."; color: #444; position: absolute; }
    .list-count { font-weight: 800; color: #ff5252; padding-left: 10px; background: rgba(15,15,15,1); position: relative; z-index: 2; }

    #about-modal { text-align: left; max-width: 600px; max-height: 85vh; overflow-y: auto; padding: 30px; border-top: 6px solid #d32f2f; }
    #about-modal h2 { margin-top: 0; color: #111; font-weight: 900; font-size: 24px; margin-bottom: 15px; }
    #about-modal p { color: #444; line-height: 1.6; margin-bottom: 15px; font-size: 14px; }
    #about-modal h3 { font-size: 12px; text-transform: uppercase; letter-spacing: 1px; margin: 25px 0 10px 0; color: #888; border-bottom: 1px solid #eee; padding-bottom: 5px; font-weight: 800; }
    
    .source-list { list-style: none; padding: 0; margin: 0; font-size: 13px; color: #555; }
    .source-list li { margin-bottom: 10px; padding-left: 15px; border-left: 3px solid #d32f2f; line-height: 1.4; }
    .source-list a { color: #d32f2f; text-decoration: none; font-weight: 700; }
    .source-list a:hover { text-decoration: underline; background: #fff0f0; }
    
    .close-btn-corner { position: absolute; top: 15px; right: 20px; background: none; border: none; font-size: 24px; cursor: pointer; color: #ccc; line-height: 1; transition: color 0.2s; }
    .close-btn-corner:hover { color: #d32f2f; }

    .btn-main {
      padding: 14px 30px; font-size: 15px; font-weight: 800; text-transform: uppercase; letter-spacing: 1px;
      border: none; border-radius: 50px; cursor: pointer; transition: transform 0.1s, box-shadow 0.2s;
      width: 100%; display: block;
    }
    .btn-danger { background: #d32f2f; color: white; box-shadow: 0 4px 15px rgba(211, 47, 47, 0.4); }
    .btn-danger:hover { background: #b71c1c; transform: translateY(-2px); }
    
    .btn-restart { background: white; color: black; box-shadow: 0 4px 15px rgba(255,255,255,0.1); }
    .btn-restart:hover { background: #eee; transform: translateY(-2px); }
    
    .btn-return { background: #f0f0f0; color: #333; margin-top: 25px; box-shadow: none; }
    .btn-return:hover { background: #e0e0e0; transform: translateY(-1px); }

  </style>
</head>
<body>

<div id="rotate-device">
  <div class="rotate-icon">↻</div>
  <h2>PLEASE ROTATE YOUR DEVICE</h2>
  <p>This simulation requires a landscape view to display the blind zones correctly.</p>
</div>

<div id="hud-top">
  <div class="brand">
    <h1>THE BLIND ZONE</h1>
    <span>FORWARD VISIBILITY OPTIONAL</span>
  </div>
  
  <div class="score-container">
    <div class="score-val" id="scoreDisplay">0</div>
    <div class="score-label">Kids Hidden</div>
  </div>

  <div class="right-controls">
    <button class="btn-hud" onclick="toggleFullscreen()">
      <span class="fs-icon">⛶</span> Full
    </button>
    <button class="btn-hud" onclick="toggleAbout(true)">
      <span class="icon">?</span> About
    </button>
    <select id="vehicleSelect" class="vehicle-selector" onchange="changeVehicle()"></select>
  </div>
</div>

<div id="sky-text">
  <h3>The driver has places to be and needs to leave! Unfortunately, children also want to be able to play.</h3>
  <p>How many children can you place before the driver spots them and is unable to drive away?</p>
</div>

<div id="sidebar-right" onclick="toggleStance()">
  <div class="panel-title">Next Up</div>
  <div id="queue-visuals"></div> 
  <div class="key-hint">Press <span class="key">S</span><br>or Click Panel</div>
  <button class="btn-toggle-stance">Toggle Sit/Stand</button>
</div>

<div id="overlay-container">
  
  <div id="warning-card" class="modal-card">
    <div class="warning-text">Stop! If you add the next child, the driver might see them and won't be able to leave.</div>
    <button class="btn-main btn-danger" onclick="startChaosSequence()">Drive away while you still can</button>
  </div>

  <div id="gameover-card" class="modal-card">
    <h2>DRIVER SPOTTED YOU</h2>
    <div id="gameover-subtitle">Congratulations, you ensured the driver wouldn't be inconvenienced by the sight of:</div>
    <div id="receipt-list"></div>
    <button class="btn-main btn-restart" onclick="resetSim()">Try Again</button>
  </div>

  <div id="about-modal" class="modal-card">
    <button class="close-btn-corner" onclick="toggleAbout(false)">&times;</button>
    <h2>About The Challenge</h2>
    <p>
      This interactive tool visualizes the "Frontover" danger posed by modern SUVs and Trucks. 
      Millions of vehicles have front blind zones large enough to hide dozens of children, yet remain perfectly legal on our roads.
    </p>
    <p>
      The goal of this "game" is to highlight the absurdity of these blind zones by challenging you to pack as many children into them as possible before they become visible to the driver.
    </p>
    
    <h3>Data Sources</h3>
    <ul class="source-list">
      <li><strong>Vehicle Blind Zones:</strong> Based on testing by <a href="https://www.wthr.com/article/news/investigations/13-investigates/13-investigates-millions-vehicles-have-unexpected-dangerous-front-blind-zone/531-9521c471-3bc1-4b55-b860-3363f0954b3b" target="_blank">WTHR 13 Investigates</a> and <a href="https://www.consumerreports.org/car-safety/the-hidden-dangers-of-big-trucks/" target="_blank">Consumer Reports</a>.</li>
      <li><strong>Child Dimensions:</strong> Anthropometric Reference Data from the <a href="https://www.cdc.gov/nchs/data/series/sr_03/sr03-046-508.pdf" target="_blank">CDC (United States)</a>.</li>
      <li><strong>Further Reading:</strong> <a href="https://www.nbcnews.com/news/us-news/americas-cars-trucks-are-getting-bigger-are-front-blind-zones-children-rcna52109" target="_blank">NBC News: America's cars are getting bigger</a>.</li>
    </ul>

    <button class="btn-main btn-return" onclick="toggleAbout(false)">Close</button>
  </div>

</div>

<script>
/* =========================================
   1. CONFIGURATION & DATA
   ========================================= */
let SCALE = 48; 
const GROUND_OFFSET = 50;

// Vehicle Data
const vehicles = {
  "Cadillac Escalade": { blindFt: 10.17, hoodH: 4.8, type: "SUV" },
  "Ford F150":         { blindFt: 9.58,  hoodH: 4.6, type: "TRUCK" },
  "Ford Explorer":     { blindFt: 8.42,  hoodH: 4.2, type: "SUV" },
  "Jeep Renegade":     { blindFt: 7.08,  hoodH: 3.9, type: "SUV" },
  "GMC Terrain":       { blindFt: 5.67,  hoodH: 3.8, type: "SUV" },
  "Honda Odyssey":     { blindFt: 5.67,  hoodH: 3.6, type: "VAN" },
  "Toyota Camry":      { blindFt: 3.25,  hoodH: 2.8, type: "SEDAN" }
};

// Child Data
const objects = [
  { 
    label: "Toddler", desc: "2yo", color: "#BA68C8", age: 2, 
    stand: { w: 0.75, h: 2.8 }, sit: { w: 1.2, h: 1.8 },
    srcStand: null, srcSit: null 
  },
  { 
    label: "Preschooler", desc: "4yo", color: "#E91E63", age: 4, 
    stand: { w: 0.8, h: 3.3 }, sit: { w: 1.4, h: 2.0 },
    srcStand: null, srcSit: null
  },
  { 
    label: "1st Grader", desc: "6yo", color: "#3F51B5", age: 6, 
    stand: { w: 0.9, h: 3.8 }, sit: { w: 1.6, h: 2.2 },
    srcStand: null, srcSit: null
  },
  { 
    label: "2nd Grader", desc: "8yo", color: "#2196F3", age: 8, 
    stand: { w: 0.95, h: 4.2 }, sit: { w: 1.7, h: 2.3 },
    srcStand: null, srcSit: null
  }
];

/* =========================================
   2. GLOBAL STATE & PHYSICS SETUP
   ========================================= */
const Engine = Matter.Engine, World = Matter.World, Bodies = Matter.Bodies, Body = Matter.Body, Runner = Matter.Runner;

let engine, world;
let ground, carBody;
let boxes = [];
let currentVeh = "Cadillac Escalade";
let objQueue = []; 
let gameState = "PLAYING"; 
let ghostPos = { x: 0, y: 0, valid: false, visible: false };
let isSitting = false; 
let isAboutOpen = false;

// Input tracking
let lastInputTime = 0;
let validTouchStarted = false; // Flag to track if touch started on canvas

/* =========================================
   3. EXPOSED UI FUNCTIONS
   ========================================= */
window.toggleAbout = function(show) {
  isAboutOpen = show;
  let modal = document.getElementById('about-modal');
  if(modal) modal.style.display = show ? 'block' : 'none';
};
window.toggleFullscreen = function() {
  if (!document.fullscreenElement) {
    document.documentElement.requestFullscreen().catch(err => {
      console.log(`Error attempting to enable fullscreen: ${err.message}`);
    });
  } else {
    if (document.exitFullscreen) {
      document.exitFullscreen();
    }
  }
};
window.toggleStance = function() {
  if (millis() - lastInputTime < 200) return; 
  lastInputTime = millis();
  
  isSitting = !isSitting;
  updateQueueUI();
  setTimeout(checkIfNextPieceFits, 50);
}

window.startChaosSequence = startChaosSequence;
window.resetSim = resetSim;
window.changeVehicle = changeVehicle;

/* =========================================
   4. P5.JS LIFECYCLE
   ========================================= */
function preload() {
  for (let obj of objects) {
    if (obj.srcStand) obj.loadedStand = loadImage(obj.srcStand);
    if (obj.srcSit)   obj.loadedSit   = loadImage(obj.srcSit);
  }
}

function calculateScale() {
  SCALE = constrain(windowWidth / 22, 30, 60);
}

function setup() {
  createCanvas(windowWidth, windowHeight);
  calculateScale();
  
  engine = Engine.create();
  world = engine.world;
  engine.constraintIterations = 4;
  engine.positionIterations = 10;
  engine.velocityIterations = 10;
  
  ground = Bodies.rectangle(width/2, height, width, 100, { isStatic: true });
  World.add(world, ground);
  
  let sel = document.getElementById('vehicleSelect');
  for(let v in vehicles) sel.add(new Option(v, v));
  sel.value = currentVeh;
  
  for(let i=0; i<4; i++) objQueue.push(floor(random(objects.length)));
  updateQueueUI();
  
  Runner.run(Runner.create(), engine);
}

function draw() {
  background(244, 244, 249);
  
  let veh = vehicles[currentVeh];
  let zoneLenPx = veh.blindFt * SCALE;
  let groundY = height - GROUND_OFFSET;
  let bumperX = width * 0.25; 
  let zoneEndX = bumperX + zoneLenPx;
  
  // A. Draw Blind Zone Overlay
  if(gameState !== "DRIVING" && gameState !== "GAMEOVER") {
    drawBlindZoneOverlay(bumperX, groundY, zoneEndX, veh);
  }

  // B. Draw Vehicle
  if(gameState === "DRIVING" && carBody) {
    let pos = carBody.position;
    push(); translate(pos.x, pos.y); rotate(carBody.angle);
    drawProceduralCar(0, 0, veh, true);
    pop();
  } else {
    drawProceduralCar(bumperX, groundY, veh, false);
  }

  // C. Draw Objects (Children)
  let currentScore = 0;
  for (let b of boxes) {
    let pos = b.body.position;
    let type = b.type;
    let dims = b.isSitting ? type.sit : type.stand;
    if(gameState === "PLAYING") currentScore++;
    push(); translate(pos.x, pos.y); rotate(b.body.angle);
    drawMeeple(0, 0, dims.w*SCALE, dims.h*SCALE, type, b.isSitting);
    pop();
  }

  // D. Floor & HUD Updates
  fill(50); noStroke(); rect(0, groundY, width, GROUND_OFFSET);
  
  if (gameState === "PLAYING") {
    document.getElementById('scoreDisplay').innerText = currentScore;
    if(objQueue.length > 0 && !isAboutOpen) {
      let nextObj = objects[objQueue[0]];
      let eX = bumperX - (2*SCALE); 
      let eY = groundY - (veh.hoodH*SCALE) - (2.0 * SCALE);
      let slope = (groundY - eY) / (zoneEndX - eX);
      drawGhost(bumperX, zoneEndX, groundY, eX, eY, slope, nextObj);
    }
  }
}

function windowResized() {
  resizeCanvas(windowWidth, windowHeight);
  calculateScale(); 
  World.remove(world, ground);
  ground = Bodies.rectangle(width/2, height, width, 100, { isStatic: true });
  World.add(world, ground);
  setTimeout(checkIfNextPieceFits, 100);
}

/* =========================================
   5. INPUT HANDLING (UPDATED)
   ========================================= */

// Prevent scrolling on mobile touches
function touchStarted() {
  // Only prevent default if we are tapping the canvas area, not the UI
  if (event && !event.target.closest('#sidebar-right, .btn-hud, .vehicle-selector')) {
    return false; 
  }
}

function keyPressed() {
  if (millis() - lastInputTime < 200) return;
  if ((key === 's' || key === 'S') && !isAboutOpen) {
    window.toggleStance();
  }
}

// 1. TOUCH START: Just validate the touch
function mousePressed() {
  if (gameState !== "PLAYING") return;
  if (isAboutOpen) return;
  
  // If clicking UI, do not start a valid drag
  if (event && event.target.closest('#sidebar-right, .btn-hud, .vehicle-selector')) {
    validTouchStarted = false;
    return;
  }
  
  // If clicking header area
  if (mouseY < 80) {
    validTouchStarted = false;
    return;
  }
  
  // If we are here, we are touching the canvas validly
  validTouchStarted = true;
}

// 2. TOUCH END: Place the piece
function mouseReleased() {
  if (!validTouchStarted) return; // Ignore if touch started on UI
  if (gameState !== "PLAYING") return;

  // Debounce check
  if (millis() - lastInputTime < 200) return;

  if (ghostPos.visible) return; // Don't place if red (visible)
  
  if (ghostPos.valid) {
    lastInputTime = millis();
    let typeIndex = objQueue.shift();
    let next = objects[typeIndex];
    objQueue.push(floor(random(objects.length)));
    updateQueueUI();
    spawnObject(ghostPos.x, ghostPos.y, next, isSitting);
    setTimeout(checkIfNextPieceFits, 50); 
  }
  
  validTouchStarted = false; // Reset flag
}

/* =========================================
   6. VISUAL HELPER FUNCTIONS
   ========================================= */
function drawBlindZoneOverlay(bumperX, groundY, zoneEndX, veh) {
    let eyeX = bumperX - (2 * SCALE); 
    let eyeY = groundY - (veh.hoodH * SCALE) - (2.0 * SCALE);
    
    noStroke(); fill(255, 50, 50, 20); 
    triangle(eyeX, eyeY, bumperX, groundY, zoneEndX, groundY);
    stroke(255, 50, 50); strokeWeight(4); line(bumperX, groundY, zoneEndX, groundY);
    
    noStroke(); fill(200, 40, 40); textAlign(CENTER); textStyle(BOLD); textSize(12);
    stroke(200, 40, 40, 100); strokeWeight(1);
    line(bumperX, groundY, bumperX, groundY + 15);
    line(zoneEndX, groundY, zoneEndX, groundY + 15);
    line(bumperX, groundY + 15, zoneEndX, groundY + 15);
    noStroke();
    let ft = Math.floor(veh.blindFt);
    let inch = Math.round((veh.blindFt - ft)*12);
    text(`${ft}' ${inch}"`, (bumperX + zoneEndX)/2, groundY + 30);

    let hPx = veh.hoodH * SCALE;
    stroke(100); strokeWeight(1);
    line(bumperX - 10, groundY, bumperX - 10, groundY - hPx);
    line(bumperX - 15, groundY - hPx, bumperX - 5, groundY - hPx); 
    line(bumperX - 15, groundY, bumperX - 5, groundY); 
    
    noStroke(); fill(100); textSize(11); textAlign(RIGHT);
    text(`${veh.hoodH} ft`, bumperX - 20, groundY - hPx/2);
}

function drawProceduralCar(x, y, veh, isPhysicsBody) {
  fill(40); noStroke();
  let hoodW = 200 * (SCALE/48); 
  let cabinW = 120 * (SCALE/48); 
  let hPx = veh.hoodH * SCALE;
  
  if (isPhysicsBody) {
    rectMode(CENTER); rect(0, 0, 400 * (SCALE/48), hPx + 50);
    fill(0); ellipse(-100, (hPx+50)/2, 60, 60); ellipse(100, (hPx+50)/2, 60, 60);
    return;
  }
  let wheelSize = 65 * (SCALE/48);
  fill(0); ellipse(x - (50*SCALE/48), y, wheelSize, wheelSize); ellipse(x - (240*SCALE/48), y, wheelSize, wheelSize);
  fill(50); rect(x - hoodW, y - hPx, hoodW, hPx);
  let cabinH = hPx + (60*SCALE/48); if(veh.type === "SEDAN") cabinH = hPx + (40*SCALE/48);
  rect(x - hoodW - cabinW, y - cabinH, cabinW + (50*SCALE/48), cabinH);
  stroke(200); strokeWeight(2); line(x, y, x, y - hPx);
  fill(200, 230, 255); noStroke();
  quad(x - hoodW, y - hPx, x - hoodW + 20, y - hPx - 40, x - hoodW - 60, y - hPx - 40, x - hoodW - 60, y - hPx);
}

function drawMeeple(x, y, w, h, typeData, sitting) {
  let img = sitting ? typeData.loadedSit : typeData.loadedStand;

  if (img) {
    imageMode(CENTER);
    image(img, 0, 0, w, h);
  } else {
    rectMode(CENTER); noStroke(); fill(typeData.color);
    let headSize = w * 0.7; let bodyH = h - headSize;
    rect(0, (headSize/2), w, bodyH, 4);
    ellipse(0, -(h/2) + (headSize/2), headSize, headSize);
    fill(255); ellipse(w*0.15, -(h/2) + (headSize/2) - 2, 4, 4);
    if(sitting) { fill(0,0,0,30); rect(w*0.3, (h/2)-5, w*0.3, 10); }
  }
}

/* =========================================
   7. CORE GAME LOGIC
   ========================================= */
function getBestY(gx, objW, objH, groundY, targetY) {
  let blockers = [];
  for(let b of boxes) {
    let dims = b.isSitting ? b.type.sit : b.type.stand;
    let bW = dims.w * SCALE; let bH = dims.h * SCALE; let bPos = b.body.position;
    if (gx - objW/2 < bPos.x + bW/2 - 0.5 && gx + objW/2 > bPos.x - bW/2 + 0.5) {
       blockers.push({ top: bPos.y - bH/2, bottom: bPos.y + bH/2 });
    }
  }
  blockers.sort((a, b) => a.top - b.top);
  let validFloors = []; let candidates = [groundY];
  for(let b of blockers) candidates.push(b.top);
  
  for(let floorY of candidates) {
    let proposedTop = floorY - objH; let fits = true;
    for(let b of blockers) {
       if(Math.abs(b.top - floorY) < 1) continue; 
       if (b.bottom > proposedTop + 0.5 && b.top < floorY - 0.5) { fits = false; break; }
    }
    if(fits) validFloors.push(floorY);
  }
  if(validFloors.length === 0) return null;
  validFloors.sort((a, b) => Math.abs(a - targetY) - Math.abs(b - targetY));
  return validFloors[0] - objH/2;
}

function drawGhost(bumperX, zoneEndX, groundY, eX, eY, slope, next) {
  let dims = isSitting ? next.sit : next.stand;
  let objW = dims.w * SCALE; let objH = dims.h * SCALE;
  let gx = constrain(mouseX, bumperX + objW/2, zoneEndX - objW/2);
  let gy = getBestY(gx, objW, objH, groundY, mouseY);
  
  if(gy === null) { ghostPos = { valid: false, visible: true }; return; }
  
  let corners = [gx - objW/2, gx, gx + objW/2];
  let visible = false; let checkY = gy - objH/2;
  for(let cx of corners) if(checkY < slope * (cx - eX) + eY) visible = true;
  
  ghostPos = { x: gx, y: gy, valid: true, visible: visible };
  
  push(); translate(gx, gy);
  
  if (visible) {
     tint(255, 50, 50, 180);
     drawMeeple(0, 0, objW, objH, next, isSitting);
  } else {
     tint(255, 255, 255, 150);
     drawMeeple(0, 0, objW, objH, next, isSitting);
  }
  noTint();

  fill(50); noStroke(); textAlign(CENTER); textSize(12); textStyle(BOLD);
  let stance = isSitting ? "Sit" : "Stand";
  let hFt = (dims.h).toFixed(1);
  let labelText = `${next.label} (${stance})`;
  let subText = `${hFt} ft`;
  
  if(visible) { fill(200, 0, 0); text("VISIBLE", 0, -objH/2 - 35); }
  
  fill(30);
  text(labelText, 0, -objH/2 - 20);
  textStyle(NORMAL); textSize(11);
  text(subText, 0, -objH/2 - 8);
  pop();
}

function checkIfNextPieceFits() {
  let next = objects[objQueue[0]];
  let veh = vehicles[currentVeh];
  let groundY = height - GROUND_OFFSET;
  let bumperX = width * 0.25; 
  let zoneEndX = bumperX + veh.blindFt*SCALE;
  let eX = bumperX - (2*SCALE); let eY = groundY - (veh.hoodH*SCALE) - (2.0 * SCALE);
  let slope = (groundY - eY) / (zoneEndX - eX);
  
  let foundSpot = false;
  for(let dims of [next.stand, next.sit]) {
    let objW = dims.w * SCALE; let objH = dims.h * SCALE;
    let minX = bumperX + objW/2; let maxX = zoneEndX - objW/2;
    for(let tx = minX; tx <= maxX; tx += 10) {
      let gy = getBestY(tx, objW, objH, groundY, groundY);
      if(gy !== null) {
        let vis = false;
        let c = [tx - objW/2, tx, tx + objW/2];
        for(let x of c) if(gy - objH/2 < slope * (x - eX) + eY) vis = true;
        if(!vis) { foundSpot = true; break; }
      }
    }
    if(foundSpot) break;
  }
  if(!foundSpot) {
    gameState = "FULL";
    document.getElementById('warning-card').style.display = "block";
  }
}

function spawnObject(x, y, typeData, sitting) {
  let dims = sitting ? typeData.sit : typeData.stand;
  let box = Bodies.rectangle(x, y, dims.w*SCALE, dims.h*SCALE, {
    isStatic: true, 
    friction: 1.0, frictionStatic: 10.0, restitution: 0.1, density: 0.002
  });
  World.add(world, box);
  boxes.push({ body: box, type: typeData, isSitting: sitting });
}

/* =========================================
   8. GAME FLOW & CHAOS MODE
   ========================================= */
function updateQueueUI() {
  let container = document.getElementById('queue-visuals');
  container.innerHTML = '';
  for(let i=0; i<3; i++) {
    let type = objects[objQueue[i]];
    let dims = isSitting ? type.sit : type.stand;
    // Scale preview based on current global scale for consistency
    let previewScale = SCALE / 3.5; 
    let w = dims.w * previewScale; let h = dims.h * previewScale;
    
    let div = document.createElement('div');
    div.style.width = w + 'px'; div.style.height = h + 'px';
    div.style.backgroundColor = type.color;
    div.style.borderRadius = "4px"; div.style.border = "1px solid rgba(0,0,0,0.2)";
    let head = document.createElement('div');
    head.style.width = (w*0.6) + 'px'; head.style.height = (w*0.6) + 'px';
    head.style.background = 'rgba(0,0,0,0.1)'; head.style.borderRadius = '50%';
    head.style.margin = '2px auto';
    div.appendChild(head);
    container.appendChild(div);
  }
}

function startChaosSequence() {
  document.getElementById('warning-card').style.display = "none";
  gameState = "DRIVING";
  engine.gravity.y = 0.2; 
  
  for(let b of boxes) Body.setStatic(b.body, false);
  
  let veh = vehicles[currentVeh];
  let h = veh.hoodH * SCALE;
  let bumperX = width * 0.25; 
  let groundY = height - GROUND_OFFSET;
  
  carBody = Bodies.rectangle(bumperX - 200, groundY - (h/2) - 10, 400, h, {
    density: 200, friction: 0, restitution: 0.5, frictionAir: 0
  });
  World.add(world, carBody);
  Body.setVelocity(carBody, { x: 15, y: 0 }); 
  
  showReceipt();
}

function showReceipt() {
  let stats = {};
  let safeCount = 0;
  let breakdown = [];

  for (let b of boxes) {
    safeCount++;
    let label = b.type.label + " (" + b.type.desc + ")";
    if(!stats[label]) stats[label] = { count: 0, age: b.type.age };
    stats[label].count++;
  }

  for (let label in stats) breakdown.push({ label: label, count: stats[label].count, age: stats[label].age });
  breakdown.sort((a, b) => b.age - a.age);

  let listHTML = "";
  for(let item of breakdown) {
    listHTML += `
      <div class="list-row">
        <div class="list-label">${item.label}</div>
        <div class="list-dots"></div>
        <div class="list-count">${item.count}</div>
      </div>
    `;
  }

  let el = document.getElementById('gameover-card');
  el.querySelector('h2').innerText = `YOU HID ${safeCount} KIDS!`;
  document.getElementById('receipt-list').innerHTML = listHTML;
  el.style.display = "block";
}

function changeVehicle() {
  resetSim();
  let sel = document.getElementById('vehicleSelect');
  currentVeh = sel.value;
}

function resetSim() {
  engine.gravity.y = 1.0; 
  for(let b of boxes) World.remove(world, b.body);
  if(carBody) World.remove(world, carBody);
  boxes = [];
  carBody = null;
  gameState = "PLAYING";
  document.getElementById('gameover-card').style.display = 'none';
  document.getElementById('warning-card').style.display = 'none';
  document.getElementById('scoreDisplay').innerText = "0";
  objQueue = [];
  for(let i=0; i<4; i++) objQueue.push(floor(random(objects.length)));
  updateQueueUI();
  
  setTimeout(checkIfNextPieceFits, 100);
}
</script>
</body>
</html>

